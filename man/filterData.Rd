% Generated by roxygen2 (4.0.2): do not edit by hand
\name{filterData}
\alias{filterData}
\alias{filter_data}
\title{Filter the positions of interest}
\usage{
filterData(data, cutoff = NULL, index = NULL, colnames = NULL,
  filter = "one", returnMean = FALSE, returnCoverage = TRUE,
  totalMapped = NULL, targetSize = 8e+07, verbose = TRUE)
}
\arguments{
\item{data}{Either a list of Rle objects or a DataFrame with the coverage
information.}

\item{cutoff}{Per base pair, at least one sample has to have coverage
strictly greater than \code{cutoff} to be included in the result.}

\item{index}{A logical Rle with the positions of the chromosome that passed
the cutoff. If \code{NULL} it is assumed that this is the first time using
\link{filterData} and thus no previous index exists.}

\item{colnames}{Specifies the column names to be used for the results
DataFrame. If \code{NULL}, names from \code{data} are used.}

\item{filter}{Has to be either \code{'one'} (default) or \code{'mean'}. In
the first case, at least one sample has to have coverage above \code{cutoff}.
In the second case, the mean coverage has to be greater than \code{cutoff}.}

\item{returnMean}{If \code{TRUE} the mean coverage is included in the result.}

\item{returnCoverage}{If \code{TRUE}, the coverage DataFrame is returned.}

\item{totalMapped}{The total number of reads mapped for each sample.
Providing this data adjusts the coverage to reads in \code{targetSize}
library prior to filtering. By default, to reads per 80 million reads.}

\item{targetSize}{The target library size to adjust the coverage to. Used
only when \code{totalMapped} is specified.}

\item{verbose}{If \code{TRUE} it will report how many rows are remaining out
of the original ones.}
}
\value{
A list with up to three components.
\code{returnMean = TRUE}.
\describe{
\item{coverage }{ is a DataFrame object where each column represents a
sample. The number of rows depends on the number of base pairs that passed
the cutoff and the information stored is the coverage at that given base.
Included only when \code{returnCoverage = TRUE}.}
\item{position }{  is a logical Rle with the positions of the chromosome
that passed the cutoff.}
\item{meanCoverage }{ is a numeric Rle with the mean coverage at each base.
Included only when \code{returnMean = TRUE}.}
}
}
\description{
For a group of samples this function reads the coverage information for a
specific chromosome directly from the BAM files. It then merges them into a
DataFrame and removes the bases that do not pass the cutoff. This is a
helper function for \link{loadCoverage} and \link{preprocessCoverage}.
}
\details{
If \code{cutoff} is \code{NULL} then the data is grouped into
DataFrame without applying any cutoffs. This can be useful if you want to
use \link{loadCoverage} to build the coverage DataFrame without applying any
cutoffs for other downstream purposes like plotting the coverage values of a
given region. You can always specify the \code{colsubset} argument in
\link{preprocessCoverage} to filter the data before calculating the F
statistics.
}
\examples{
## Construct some toy data
library('IRanges')
x <- Rle(round(runif(1e4, max=10)))
y <- Rle(round(runif(1e4, max=10)))
z <- Rle(round(runif(1e4, max=10)))
DF <- DataFrame(x, y, z)

## Filter the data
filt1 <- filterData(DF, 5)
filt1

## Filter again but only using the first two samples
filt2 <- filterData(filt1$coverage[, 1:2], 5, index=filt1$position)
filt2
}
\author{
Leonardo Collado-Torres
}
\seealso{
\link{loadCoverage}, \link{preprocessCoverage}
}

