[derfinder2](https://github.com/lcolladotor/derfinder2) basic results exploration
=================================================================================

Project: `r project`.

# Introduction

This report is meant to help explore the results of the `derfinder2` `r mycitep(bib[["derfinder2"]])` package. While the report is rich, it is meant to just start the exploration of the results and exemplify some of the code used to do so. You will most likely need a more in-depth analysis for your specific data set.

Most plots were made with using `ggplot2` `r mycitep(bib[["ggplot2"]])`.

## Code setup

```{r setup}
## For ggplot
tmp <- fullRegions
names(tmp) <- seq_len(length(tmp))
regions.df <- as.data.frame(tmp)
regions.df$width <- width(tmp)
rm(tmp)
nulls.df <- as.data.frame(fullNullSummary)

## Get chr lengths
if(hg19) {
	data(hg19Ideogram, package = "biovizBase")
	seqlengths(fullRegions) <- seqlengths(hg19Ideogram)[names(seqlengths(fullRegions))]
}

## Find which chrs are present in the data set
chrs <- levels(seqnames(fullRegions))
names(chrs) <- gsub("chr", "", chrs)

## Subset the fullCoverage data in case that a subset was used
colsubset <- optionsStats$colsubset
if(!is.null(fullCov) & !is.null(colsubset)) {
	fullCov <- lapply(fullCov, function(x) { x[, colsubset] })
}

## Get region coverage for the top regions
if(nBestRegions > 0) {
	regionCoverage <- getRegionCoverage(fullCov=fullCov, regions=fullRegions[seq_len(nBestRegions)], calculateMeans=FALSE, verbose=FALSE)
	save(regionCoverage, file="regionCoverage.Rdata")
}
```


# Quality checks

## P-values

Theoretically, the p-values should be uniformly distributed between 0 and 1.

```{r pvals, fig.width=10, fig.height=10, dev=device, eval=nullExist, echo=nullExist}
p1 <- ggplot(regions.df, aes(x=pvalues, colour=seqnames)) + geom_line(stat="density") + xlim(0, 1) + labs(title="Density of p-values") + xlab("p-values") + scale_colour_discrete(limits=chrs) + theme(legend.title=element_blank())
p1
```

```{r summPval, eval=nullExist, echo=nullExist}
## Compare the pvalues
summary(fullRegions$pvalues)
```

This is the numerical summary of the distribution of the p-values. `r ifelse(nullExist, "", "Skipped because there are no null regions.")`

## Q-values

```{r summQval, eval=nullExist, echo=nullExist}
summary(fullRegions$qvalues)
```

This is the numerical summary of the distribution of the q-values. `r ifelse(nullExist, "", "Skipped because there are no null regions.")`

```{r qsummary, eval=nullExist, echo=nullExist, results="asis"}
qtable <- lapply(c(1e-04, 0.001, 0.01, 0.025, 0.05, 0.1, 1), function(x) {
	data.frame("Cut" = x, "Count" = sum(fullRegions$qvalues < x))
})
qtable <- do.call(rbind, qtable)
print(xtable(qtable, digits=4, align=rep("c", 3)), type="html", include.rownames=FALSE)
```

This table shows the number of candidate Differentially Expressed Regions (DERs) with q-value less than some commonly used cutoff values. `r ifelse(nullExist, "", "Skipped because there are no null regions.")`

## Region width

```{r regLen, fig.width=14, fig.height=14, dev=device, eval=hasSig, echo=hasSig}
xrange <- range(log10(regions.df$width))
p2a <- ggplot(regions.df, aes(x=log10(width), colour=seqnames)) + geom_line(stat="density") + labs(title="Density of region lengths") + xlab("Region width (log10)") + scale_colour_discrete(limits=chrs) + xlim(xrange) + theme(legend.title=element_blank())
p2b <- ggplot(regions.df[idx.sig, ], aes(x=log10(width), colour=seqnames)) + geom_line(stat="density") + labs(title="Density of region lengths (significant only)") + xlab("Region width (log10)") + scale_colour_discrete(limits=chrs) + xlim(xrange) + theme(legend.title=element_blank())
grid.arrange(p2a, p2b)
```

```{r regLen2, fig.width=10, fig.height=10, dev=device, eval=!hasSig, echo=!hasSig}
p2a <- ggplot(regions.df, aes(x=log10(width), colour=seqnames)) + geom_line(stat="density") + labs(title="Density of region lengths") + xlab("Region width (log10)") + scale_colour_discrete(limits=chrs) + theme(legend.title=element_blank())
p2a
```

This plot shows the density of the region lengths for all regions. `r ifelse(hasSig, paste0("The bottom panel is restricted to significant regions (q-value < ", optionsMerge$significantCut[2], ")"), "")`

## Region Area

```{r regArea, fig.width=14, fig.height=14, dev=device, eval=hasSig, echo=hasSig}
xrange <- range(log10(regions.df$area))
p3a <- ggplot(regions.df, aes(x=log10(area), colour=seqnames)) + geom_line(stat="density") + labs(title="Density of region areas") + xlab("Region area (log10)") + scale_colour_discrete(limits=chrs) + xlim(xrange) + theme(legend.title=element_blank())
p3b <- ggplot(regions.df[idx.sig, ], aes(x=log10(area), colour=seqnames)) + geom_line(stat="density") + labs(title="Density of region areas (significant only)") + xlab("Region area (log10)") + scale_colour_discrete(limits=chrs) + xlim(xrange) + theme(legend.title=element_blank())
grid.arrange(p3a, p3b)
```

```{r regArea2, fig.width=10, fig.height=10, dev=device, eval=!hasSig, echo=!hasSig}
p3a <- ggplot(regions.df, aes(x=log10(area), colour=seqnames)) + geom_line(stat="density") + labs(title="Density of region areas") + xlab("Region area (log10)") + scale_colour_discrete(limits=chrs) + theme(legend.title=element_blank())
p3a
```

This plot shows the density of the region areas for all regions. `r ifelse(hasSig, paste0("The bottom panel is restricted to significant regions (q-value < ", optionsMerge$significantCut[2], ")"), "")`

## Null regions: width and area

```{r nullLengthArea, fig.width=14, fig.height=14, dev=device, eval=nullExist, echo=nullExist}
p4 <- ggplot(nulls.df, aes(x=log10(width), colour=chr)) + geom_line(stat="density") + labs(title="Density of null region lengths") + xlab("Region width (log10)") + scale_colour_discrete(limits=chrs) + theme(legend.title=element_blank())
p5 <- ggplot(nulls.df, aes(x=log10(area), colour=chr)) + geom_line(stat="density") + labs(title="Density of null region areas") + xlab("Region area (log10)") + scale_colour_discrete(limits=chrs) + theme(legend.title=element_blank())
grid.arrange(p4, p5)
```

This plot shows the density of the null region lengths and areas. `r ifelse(nullExist, "", "Skipped because there are no null regions.")`

## Mean coverage

```{r meanCov, fig.width=14, fig.height=14, dev=device, eval=hasSig, echo=hasSig}
xrange <- range(log2(regions.df$meanCoverage))
p6a <- ggplot(regions.df, aes(x=log2(meanCoverage), colour=seqnames)) + geom_line(stat="density") + labs(title="Density of region mean coverage") + xlab("Region mean coverage (log2)") + scale_colour_discrete(limits=chrs) + xlim(xrange) + theme(legend.title=element_blank())
p6b <- ggplot(regions.df[idx.sig, ], aes(x=log2(meanCoverage), colour=seqnames)) + geom_line(stat="density") + labs(title="Density of region mean coverage (significant only)") + xlab("Region mean coverage (log2)") + scale_colour_discrete(limits=chrs) + xlim(xrange) + theme(legend.title=element_blank())
grid.arrange(p6a, p6b)
```

```{r meanCov2, fig.width=10, fig.height=10, dev=device, eval=!hasSig, echo=!hasSig}
p6a <- ggplot(regions.df, aes(x=log2(meanCoverage), colour=seqnames)) + geom_line(stat="density") + labs(title="Density of region mean coverage") + xlab("Region mean coverage (log2)") + scale_colour_discrete(limits=chrs) + theme(legend.title=element_blank())
p6a
```

This plot shows the density of the region mean coverage for all regions. `r ifelse(hasSig, paste0("The bottom panel is restricted to significant regions (q-value < ", optionsMerge$significantCut[2], ")"), "")`


## Mean coverage vs fold change

The following plots are [MA](http://en.wikipedia.org/wiki/MA_plot)-style plots comparing each group vs the first one. The mean coverage is calculated using only two groups at a time and is weighted according to the number of samples on each group. Note that the mean coverage and fold change as calculated here do not taking into account the library sizes.

These plots are only shown when there are two or more groups. A total of `r length(grep("foldChange", colnames(values(fullRegions))))` were made.

```{r MAstyle, fig.width=10, fig.height=10, dev=device}
for(j in grep("foldChange", colnames(values(fullRegions)))) {
	## Identify the groups
	groups <- strsplit(gsub("foldChange", "", colnames(values(fullRegions))[j]), "vs")[[1]]
	
	## Calculate the mean coverage only using the 2 groups in question
	j.mean <- which(colnames(values(fullRegions)) %in% paste0("mean", groups))
	groups.n <- sapply(groups, function(x) { sum(optionsStats$groupInfo == x) })
	ma.mean.mat <- as.matrix(values(fullRegions)[, j.mean])
	## Weighted means
	ma.mean <- drop(ma.mean.mat %*% groups.n) / sum(groups.n)
	
	ma <- data.frame(mean=ma.mean, foldChange=values(fullRegions)[, j])
	ma2 <- ma[is.finite(ma$foldChange), ]
	fold.mean <- data.frame(foldMean=mean(ma2$foldChange, na.rm=TRUE))
	
	p.ma <- ggplot(ma, aes(x=log2(mean), y=foldChange)) + geom_point(size=1.5, alpha=1/5) + ylab("Fold Change (log2)\nRed dashed line at mean; blue line is loess fit") + xlab(paste("Mean coverage (log2) using only groups", groups[1], "and", groups[2])) + labs(title=paste("MA style plot:", groups[1], "vs ", groups[2])) + geom_hline(aes(yintercept=foldMean), data=fold.mean, colour="#990000", linetype="dashed") + geom_smooth(aes(y=foldChange, x=log2(mean)), data=subset(ma2, mean > 0), method=loess)
	print(p.ma)
}
```


# Genomic overview

The following plots were made using `ggbio` `r mycitep(bib[["ggbio"]])` which in turn uses `ggplot2` `r mycitep(bib[["ggplot2"]])`. For more details check `plotOverview` in `derfinder2` `r mycitep(bib[["derfinder2"]])`.

## Q-values

```{r genomeOverview1, message=FALSE, fig.width=7, fig.height=9, dev=device, dpi=300, eval=nullExist, echo=nullExist}
plotOverview(regions=fullRegions, type="qval", base_size=30, areaRel=10, legend.position=c(0.97, 0.12))
```

This plot shows the genomic locations of the __candidate__ regions found in the analysis. The significant regions (q-value less than `r optionsMerge$significantCut[2]`) are highlighted and the area of the regions is shown on top of each chromosome. Note that the area is in a relative scale.


## Annotation

```{r genomeOverview2, message=FALSE, fig.width=7, fig.height=9, dev=device, dpi=300}
plotOverview(regions=fullRegions, annotation=fullRegions, type="annotation", base_size=30, areaRel=10, legend.position=c(0.97, 0.12))
```

This genomic overview plot shows the annotation region type for the __candidate__ regions. Note that the regions are shown only if the annotation information is available. Below is a table of the actual number of results per annotation region type.

```{r annoReg, results="asis"}
annoReg <- table(fullRegions$region, useNA="always")
annoReg.df <- data.frame(Region=names(annoReg), Count=as.vector(annoReg))
print(xtable(annoReg.df, align=rep("c", 3)), type="html", include.rownames=FALSE)
```

## Annotation (significant)

```{r genomeOverview3, message=FALSE, fig.width=7, fig.height=9, dev=device, dpi=300, eval=hasSig, echo=hasSig}
plotOverview(regions=fullRegions[idx.sig], annotation=fullRegions[idx.sig], type="annotation", base_size=30, areaRel=10, legend.position=c(0.97, 0.12))
```

This genomic overview plot shows the annotation region type for the __candidate__ regions that have a q-value less than `r optionsMerge$significantCut[2]`. Note that the regions are shown only if the annotation information is available. `r ifelse(hasSig, "", "Plot skipped because there are no significant regions.")`


# Best regions



## Plots

Below are the plots for the top `r nBestRegions` candidate DERs as ranked by area. For each plot, annotation is shown if the candidate DER has a minimum overlap of `r optionsMerge$minoverlap` base pairs with annotation information (strand specific). If present, exons are collapsed and shown in blue. Introns are shown in light blue.

```{r refGenomicState, results="asis"}
cat(paste0("The annotation depends on the <code>Genomic State<code> used. For details on which one was used for this report check the call to <code>mergeResults<code> <a href='", output, "#Details'>in the reproducibility details.</a>"))
```


```{r plotRegions, fig.width=10, fig.height=10, dev=device}
if(nBestRegions > 0) {
	plotRegionCoverage(regions=fullRegions, regionCoverage=regionCoverage, groupInfo=optionsStats$groupInfo, nearestAnnotation=regions.df, annotatedRegions=fullAnnotatedRegions, whichRegions = seq_len(min(nBestRegions, length(fullRegions))), colors=NULL, scalefac = 32, ask = FALSE, verbose = FALSE) 
}
```

Below is a table summarizing the number of genomic states per region.

```{r countTable, results="asis"}
info <- do.call(rbind, lapply(fullAnnotatedRegions$countTable, function(x) { data.frame(table(x)) }))
colnames(info) <- c("Number of Overlapping States", "Frequency")
info$State <- gsub("\\..*", "", rownames(info))
rownames(info) <- NULL
print(xtable(info, align=rep("c", 4)), type="html", include.rownames=FALSE)
```


## Region information

Below is an interactive table with the top `r nBestRegions` regions as ranked by area. This table was generated using `rCharts` `r mycitep(bib[["rCharts"]])`.

<link rel="stylesheet" href="http://ajax.aspnetcdn.com/ajax/jquery.dataTables/1.9.4/css/jquery.dataTables.css" />
<script src="http://ajax.aspnetcdn.com/ajax/jquery.dataTables/1.9.4/jquery.dataTables.min.js"></script>

```{r bestAreaInfo, results="asis"}
topArea <- head(regions.df, nBestRegions)
topArea <- data.frame("areaRank"=order(topArea$area, decreasing=TRUE), topArea)
## Clean up -Inf, Inf if present
## More details at https://github.com/ramnathv/rCharts/issues/259
replaceInf <- function(df, colsubset=seq_len(ncol(df))) {
	for(i in colsubset) {
		inf.idx <- !is.finite(df[, i])
		if(any(inf.idx)) {
			inf.sign <- sign(df[inf.idx, i])
			df[inf.idx, i] <- inf.sign * 1e100
		}
	}
	return(df)
}
topArea <- replaceInf(topArea, grep("foldChange", colnames(topArea)))

## Make the table
d <- data.table(topArea)
t1 <- dTable(d, sPaginationType=  'full_numbers', iDisplayLength=10, sScrollX='100%')
t1$print("regions", cdn=TRUE)
```

`r ifelse(any(inf.idx), "Inf and -Inf are shown as 1e100 and -1e100 respectively.", "")`


# Best region clusters

The following plots were made using `ggbio` `r mycitep(bib[["ggbio"]])` which in turn uses `ggplot2` `r mycitep(bib[["ggplot2"]])`. For more details check `plotRegion` in `derfinder2` `r mycitep(bib[["derfinder2"]])`. 

## Plots

```{r plotCluster, message=FALSE, eval=makeBestClusters, echo=makeBestClusters}
## Select clusters by cluster area
df <- data.frame(area=fullRegions$area, clusterChr=paste0(as.integer(fullRegions$cluster), chr=as.character(seqnames(fullRegions))))
regionClustAreas <- tapply(df$area, df$clusterChr, sum)
bestArea <- sapply(names(head(sort(regionClustAreas, decreasing=TRUE), nBestClusters)), function(y) { which(df$clusterChr == y)[[1]]})

## Graphical setup: ideograms 
if(hg19 & is.null(p.ideos)) {
	ideos.set <- as.character(unique(seqnames(fullRegions[bestArea])))
	p.ideos <- lapply(ideos.set, function(xx) { 
		plotIdeogram(genome = "hg19", subchr=xx)
	})
	names(p.ideos) <- ideos.set
} else {
	stopifnot(!is.null(p.ideos))
}

## Graphical setup: transcription database
if(hg19 & is.null(txdb)) {
	txdb <- TxDb.Hsapiens.UCSC.hg19.knownGene
} else {
	stopifnot(!is.null(txdb))
}

## Graphical setup: main plotting function
regionClusterPlot <- function(idx, tUse="qval") {
	## Chr specific selections
	chr <- as.character(seqnames(fullRegions[idx]))
	chrnum <- gsub("chr", "", chr)
	p.ideo <- p.ideos[[chr]]
	covInfo <- fullCov[[chrnum]]
	
	## Make the plot
	p <- plotCluster(idx, regions=fullRegions, annotation=regions.df, coverageInfo=covInfo, groupInfo=optionsStats$groupInfo, titleUse=tUse, txdb=txdb, p.ideogram=p.ideo)
	print(p)
	rm(p.ideo, covInfo)
	
	return(invisible(TRUE))	
}
```

Below are the best `r nBestClusters` region clusters ordered by cluster area (sum of the area of regions inside a cluster). The region with the highest area in the cluster is shown with a red bar. `r ifelse(makeBestClusters, "", "No plots were generated as requested.")`


```{r bestClusters, message=FALSE, fig.width=20, fig.height=10, dev=device, eval=makeBestClusters, echo=makeBestClusters}

## Genome plots
for(idx in bestArea) {
	regionClusterPlot(idx, ifelse(nullExist, "qval", "none"))
}
```


# Permutations

Below is the information on how the samples were permutted. 

## Summary

```{r permute2, eval=usedPermutations, echo=usedPermutations}
## Get the permutation information
nSamples <- seq_len(length(optionsStats$groupInfo))
permuteInfo <- lapply(seeds, function(x) {
	set.seed(x)
	idx <- sample(nSamples)
	data.frame(optionsStats$groupInfo[idx])
})
permuteInfo <- cbind(data.frame(optionsStats$groupInfo), do.call(cbind, permuteInfo))
colnames(permuteInfo) <- c("original", paste0("perm", 1:10))
## The raw information
# permuteInfo

n <- names(table(permuteInfo[, 2]))
permuteDetail <- data.frame(matrix(NA, nrow=10*length(n), ncol = 2 + length(n)))
permuteDetail[, 1] <- rep(1:10, each=length(n))
permuteDetail[, 2] <- rep(n, 10)
colnames(permuteDetail) <- c("permutation", "group", as.character(n))
l <- 1
m <- 3:ncol(permuteDetail)
for(j in n) {
	k <- which(permuteInfo[, 1] == j)
	for(i in 2:11) {
		permuteDetail[l, m] <- table(permuteInfo[k, i])
		l <- l + 1
	}
}

## Print the summary
summary(permuteDetail[, m])
```

This table shows the summary per group of and can be used for fast detection of anomalies. `r ifelse(usedPermutations, "", "Skipped because no permutations were used.")`

Note that in `derfinder2` `r mycitep(bib[["derfinder2"]])` the re-sampling of the samples is done without replacement. This is done in an effort to avoid singular model matrices. While the sample balance is the same across the permutations, what changes are the adjusted variables (including the column medians).

## Interactive

The following table shows how the group labels were permuted. `r ifelse(usedPermutations, "", "Skipped because no permutations were used.")` This can be useful to detect whether a permutation in particular had too many samples of a group labeled as another group, meaning that the resulting permuted group label resulted in pretty much a name change.

```{r permuteTable, results="asis", eval=usedPermutations, echo=usedPermutations}
d2 <- data.table(permuteDetail)
t2 <- dTable(d2, sPaginationType=  'full_numbers', iDisplayLength=10, sScrollX='100%')
t2$print("permutation")
```




# Bibliography

This report is part of `derfinder2` `r mycitep(bib[["derfinder2"]])` and was generated using `knitr` `r mycitep(bib[["knitr"]])` and styled via `knitrBootstrap` `r mycitep(bib[["knitrBootstrap"]])`.

Citations made with `knitcitations` `r mycitep(bib[["knitcitations"]])`.

```{r bibliography, results='asis', echo=FALSE, cache=FALSE}
## Print bibliography
bibliography()
```

# Reproducibility

## General information

The F-statistic cutoff used was `r as.character(optionsStats$cutoffFstat)` and type of cutoff used was `r optionsStats$cutoffType`. Furthermore, the maximum region (data) gap was set to `r optionsStats$maxRegionGap` and the maximum cluster gap was set to `r optionsStats$maxClusterGap`.

## Details

This analysis was on each chromosome was perfomed with the following call to `analyzeChr()` (shown for one chromosome only):

```{r analysisCall, echo=FALSE}
if("analyzeCall" %in% names(optionsStats)) {
	optionsStats$analyzeCall
} else {
	"Skipped since this information was not recorded prior to version 0.0.24"
}
```

The results were merged using the following call to `mergeResults()`:

```{r mergeCall, echo=FALSE}
optionsMerge$mergeCall
```

This report was generated in path `r tmpdir` using the following call to `generateReport()`:

```{r thecall, echo=FALSE}
theCall
```

Date the report was generated.

```{r reproducibility1, echo=FALSE}
## Date the report was generated
Sys.time()
```

Wallclock time spent generating the report.

```{r reproducibility2, echo=FALSE}
## Processing time in seconds
totalTime <- diff(c(startTime, Sys.time()))
round(totalTime, digits=3)
```

`R` session information.

```{r reproducibility3, echo=FALSE}
## Session info
sessionInfo()
```
